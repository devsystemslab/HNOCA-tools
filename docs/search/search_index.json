{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome the Website of the Human Neural Organoid Cell Atlas (HNOCA)","text":"<p>The Human Neural Organoid Cell Atlas (HNOCA) is a collection of single-cell RNA-seq data from human brain organoids. The HNOCA is a resource for the scientific community to explore the cellular composition of human brain organoids and to understand the molecular mechanisms underlying brain development and disease.</p>"},{"location":"archmap/","title":"How to map query data to the HNOCA using ArchMap","text":""},{"location":"quickstart/","title":"Human Neural Organoid Cell Atlas Toolbox","text":"<p>The HNOCA-tools provides a set of tools we used to generate and analyze the Human Neural Organoid Cell Atlas. Among other things, it provides functions to:</p> <ul> <li>Rapidly annotate cell types based on marker genes</li> <li>Map query data to the reference atlas</li> <li>Transfer annotations between datasets</li> <li>Compute 'presence scores' for query data based on the reference atlas</li> <li>Perform differential expression analysis</li> </ul>"},{"location":"quickstart/#quick-start","title":"Quick start","text":""},{"location":"quickstart/#annotation","title":"\ud83d\udd8b\ufe0f Annotation","text":"<p>We developed snapseed to rapidly annotate the HNOCA. It annotates cells based on manually defined sets of marker genes for individual cell types or cell type hierarchies. It is fast (i.e. GPU-accelerated) and simple to enable annotation of very large datasets.</p> <pre><code>import hnoca.snapseed as snap\nfrom hnoca.snapseed.utils import read_yaml\n\n# Read in the marker genes\nmarker_genes = read_yaml(\"marker_genes.yaml\")\n\n# Annotate anndata objects\nsnap.annotate(\n    adata,\n    marker_genes,\n    group_name=\"clusters\",\n    layer=\"lognorm\",\n)\n\n# Or for more complex hierarchies\nsnap.annotate_hierarchy(\n    adata,\n    marker_genes,\n    group_name=\"clusters\",\n    layer=\"lognorm\",\n)\n</code></pre>"},{"location":"quickstart/#mapping","title":"\ud83d\uddfa\ufe0f Mapping","text":"<p>For reference mapping, we mostly rely on scPoli and scANVI. Based on pretrained models, we here provide a simple interface to map query data to the reference atlas.</p> <pre><code>import scvi\nimport hnoca.map as mapping\n\n# Load the reference model\nref_model = scvi.model.SCANVI.load(\n    os.path.join(\"model.pt\"),\n    adata=ref_adata,\n)\n\n# Map query data\nmapper = mapping.AtlasMapper(ref_model)\nmapper.map_query(query_adata, retrain=\"partial\", max_epochs=100, batch_size=1024)\n</code></pre> <p>Now that the query dataset is mapped, we can perform kNN-based label transfer and presence score calculation.</p> <pre><code># Compute the weighted kNN\nmapper.compute_wknn(k=100)\n\n# Transfer labels\ncelltype_transfer = mapper.transfer_labels(label_key=\"cell_type\")\npresence_scores = mapper.get_presence_scores(split_by=\"batch\")\n</code></pre>"},{"location":"quickstart/#differential-expression","title":"\ud83d\udcca Differential expression","text":"<p>We have used ANOVA for DE analysis between the HNOCA and the reference atlas. Here, this is implemented as the <code>test_de()</code> function.</p> <pre><code>import hnoca.stats as stats\n\n# Perform DE analysis\nde_df = stats.test_de(\n    joint_adata,\n    group_key=\"origin\",\n    return_coef_group=\"organoid\",\n    adjust_method=\"holm\",\n)\n</code></pre> <p>In addition to DE testing on the atlas itself, we found it useful to treat the atlas as a universal \"control\" and test for DE w.r.t query datasets. For this, we first compute the matched expression profile for each cell in the query dataset and then test for DE using an F-test.</p> <pre><code># Compute matched expression profiles based on mapped data\nmatched_adata = mapper.get_matched_expression()\n\n# Perform DE analysis\nde_df = stats.test_de_paired(\n    query_adata,\n    matched_adata,\n    adjust_method=\"holm\",\n)\n</code></pre>"},{"location":"api/map/AtlasMapper/","title":"AtlasMapper","text":""},{"location":"api/map/AtlasMapper/#hnoca.map.mapper.AtlasMapper","title":"<code>hnoca.map.mapper.AtlasMapper(ref_model)</code>","text":"<p>A class to map a query dataset to a reference dataset using scPoli, scVI or scANVI models.</p> <p>Parameters:</p> Name Type Description Default <code>ref_model</code> <code>Union[SCANVI, SCVI, scPoli]</code> <p>The reference model to map the query dataset to.</p> required"},{"location":"api/map/AtlasMapper/#hnoca.map.mapper.AtlasMapper.map_query","title":"<code>map_query(query_adata, retrain, **kwargs)</code>","text":"<p>Map a query dataset to the reference dataset</p> <p>Parameters:</p> Name Type Description Default <code>query_adata</code> <code>AnnData</code> <p>The query dataset to map to the reference dataset</p> required <code>retrain</code> <code>Literal['partial', 'full', 'none']</code> <p>Whether to retrain the query model.</p> <ul> <li><code>\"partial\"</code> will retrain the weights of the new batch key</li> <li><code>\"full\"</code> will retrain the entire model</li> <li><code>\"none\"</code> will use the reference model without retraining</li> </ul> required <code>kwargs</code> <p>Additional keyword arguments to pass to the training function</p> <code>{}</code>"},{"location":"api/map/AtlasMapper/#hnoca.map.mapper.AtlasMapper.compute_wknn","title":"<code>compute_wknn(ref_adata=None, k=100, query2ref=True, ref2query=False, weighting_scheme='jaccard_square', top_n=None)</code>","text":"<p>Compute the weighted k-nearest neighbors graph between the reference and query datasets</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>Number of neighbors per cell</p> <code>100</code> <code>query2ref</code> <code>bool</code> <p>Consider query-to-ref neighbors</p> <code>True</code> <code>ref2query</code> <code>bool</code> <p>Consider ref-to-query neighbors</p> <code>False</code> <code>weighting_scheme</code> <code>Literal['n', 'top_n', 'jaccard', 'jaccard_square', 'gaussian', 'dist']</code> <p>How to weight edges in the ref-query neighbor graph</p> <code>'jaccard_square'</code> <code>top_n</code> <code>Optional[int]</code> <p>The number of top neighbors to consider</p> <code>None</code>"},{"location":"api/map/AtlasMapper/#hnoca.map.mapper.AtlasMapper.get_presence_scores","title":"<code>get_presence_scores(split_by=None, random_walk=True, alpha=0.1, n_rounds=100, log=True)</code>","text":"<p>Estimate the presence score of the query dataset</p> <p>Parameters:</p> Name Type Description Default <code>split_by</code> <code>str</code> <p>The column in the query dataset to split by</p> <code>None</code> <code>random_walk</code> <code>bool</code> <p>Whether to use random walk to estimate presence score</p> <code>True</code> <code>alpha</code> <code>float</code> <p>The heat diffusion parameter for the random walk</p> <code>0.1</code> <code>n_rounds</code> <code>int</code> <p>The number of rounds for the random walk</p> <code>100</code> <code>log</code> <code>bool</code> <p>Whether to log the presence score</p> <code>True</code>"},{"location":"api/map/AtlasMapper/#hnoca.map.mapper.AtlasMapper.transfer_labels","title":"<code>transfer_labels(label_key)</code>","text":"<p>Transfer labels from the reference dataset to the query dataset</p> <p>Parameters:</p> Name Type Description Default <code>label_key</code> <code>str</code> <p>str The column in the reference dataset to transfer</p> required"},{"location":"api/map/AtlasMapper/#hnoca.map.mapper.AtlasMapper.get_matched_expression","title":"<code>get_matched_expression(rescale_factor=1)</code>","text":"<p>Get the expression of reference cells matched to query cells. This can be used for quantitative comparisons like DE analysis.</p> <p>Parameters:</p> Name Type Description Default <code>rescale_factor</code> <code>int</code> <p>str Factor to rescale the log-normalized counts</p> <code>1</code>"},{"location":"api/map/AtlasMapper/#hnoca.map.mapper.AtlasMapper.save","title":"<code>save(output_dir)</code>","text":"<p>Save the mapper object to disk</p> <p>Parameters:</p> Name Type Description Default <code>output_dir</code> <code>str</code> <p>str The directory to save the mapper object</p> required"},{"location":"api/map/AtlasMapper/#hnoca.map.mapper.AtlasMapper.load","title":"<code>load(input_dir)</code>  <code>classmethod</code>","text":"<p>Load the mapper object from disk</p> <p>Parameters:</p> Name Type Description Default <code>input_dir</code> <code>str</code> <p>str The directory to load the mapper object</p> required"},{"location":"api/snapseed/annotate/","title":"annotate","text":""},{"location":"api/snapseed/annotate/#hnoca.snapseed.annotate.annotate","title":"<code>hnoca.snapseed.annotate.annotate(adata, marker_dict, group_name, layer=None, **kwargs)</code>","text":"<p>Annotate clusters based on a manually defined cell type markers.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>AnnData object</p> required <code>marker_dict</code> <code>dict</code> <p>Dict with marker genes for each celltype</p> required <code>group_name</code> <code>str</code> <p>Name of the column in adata.obs that contains the cluster labels</p> required <code>layer</code> <code>str</code> <p>Layer in adata to use for expression</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments to pass to the annotation function.</p> <code>{}</code> <p>Returns:</p> Type Description <p>pd.DataFrame with assignments</p>"},{"location":"api/snapseed/annotate_hierarchy/","title":"annotate_hierarchy","text":""},{"location":"api/snapseed/annotate_hierarchy/#hnoca.snapseed.annotate.annotate_hierarchy","title":"<code>hnoca.snapseed.annotate.annotate_hierarchy(adata, marker_hierarchy, group_name, layer=None, min_expr=0.1, **kwargs)</code>","text":"<p>Annotate clusters based on a manually defined cell type and marker hierarchy.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>AnnData object</p> required <code>marker_hierarchy</code> <code>dict</code> <p>dict arker genes for each celltype arranged hierarchically.</p> required <code>group_name</code> <code>str</code> <p>Name of the column in adata.obs that contains the cluster labels</p> required <code>layer</code> <code>str</code> <p>Layer in adata to use for expression</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments to pass to the annotation function.</p> <code>{}</code> <p>Returns:</p> Type Description <p>Dict with assignments and metrics</p>"},{"location":"api/snapseed/find_markers/","title":"find_markers","text":""},{"location":"api/snapseed/find_markers/#hnoca.snapseed.markers.find_markers","title":"<code>hnoca.snapseed.markers.find_markers(adata, group_name, features=None, layer=None)</code>","text":"<p>Find markers for each cluster.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <p>AnnData object</p> required <code>group_name</code> <p>Name of the column in adata.obs that contains the cluster labels</p> required <code>features</code> <p>List of features to use for marker identification</p> <code>None</code> <code>layer</code> <p>Layer in adata to use for expression</p> <code>None</code> <p>Returns:</p> Type Description <p>DataFrame with AUROC and detection ratio for each gene and cluster.</p>"},{"location":"api/stats/test_de/","title":"test_de","text":""},{"location":"api/stats/test_de/#hnoca.stats.de.test_de","title":"<code>hnoca.stats.de.test_de(adata, group, covar, num_threads=1, return_coef_group=None, var_names=None, adjust_method='holm')</code>","text":"<p>Test for differential expression using ANOVA</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>AnnData object</p> required <code>group</code> <code>Union[str, Series]</code> <p>str or pd.Series The group labels</p> required <code>covar</code> <code>Union[str, DataFrame]</code> <p>str or pd.DataFrame The covariates</p> required <code>num_threads</code> <code>int</code> <p>int The number of threads to use</p> <code>1</code> <code>return_coef_group</code> <code>str</code> <p>str The group to return coefficients for</p> <code>None</code> <code>var_names</code> <code>list</code> <p>list The variable names to test</p> <code>None</code> <code>adjust_method</code> <code>str</code> <p>str The method to adjust p-values. See https://www.statsmodels.org/dev/generated/statsmodels.stats.multitest.multipletests.html</p> <code>'holm'</code> <p>Returns:</p> Type Description <p>pd.DataFrame The differential expression results</p>"},{"location":"api/stats/test_de_paired/","title":"test_de_paired","text":""},{"location":"api/stats/test_de_paired/#hnoca.stats.de.test_de_paired","title":"<code>hnoca.stats.de.test_de_paired(query_adata, matched_adata, covar, num_threads=1, var_names=None, adjust_method='holm')</code>","text":"<p>Test for differential expression between query data and matches reference cells using an F-test.</p> <p>Parameters:</p> Name Type Description Default <code>query_adata</code> <code>AnnData</code> <p>AnnData object The query data</p> required <code>matched_adata</code> <code>AnnData</code> <p>AnnData object The matched reference data</p> required <code>covar</code> <code>Union[str, DataFrame]</code> <p>str or pd.DataFrame The covariates</p> required <code>num_threads</code> <code>int</code> <p>int The number of threads to use</p> <code>1</code> <code>var_names</code> <code>list</code> <p>list The variable names to test</p> <code>None</code> <code>adjust_method</code> <code>str</code> <p>str The method to adjust p-values. See https://www.statsmodels.org/dev/generated/statsmodels.stats.multitest.multipletests.html</p> <code>'holm'</code> <p>Returns:</p> Type Description <p>pd.DataFrame The differential expression results</p>"},{"location":"vignettes/get_started/","title":"Get started with the Human Neural Organoid Cell Atlas Toolbox","text":"<p>The HNOCA-tools provides a set of tools we used to generate and analyze the Human Neural Organoid Cell Atlas. Among other things, it provides functions to:</p> <ul> <li>Rapidly annotate cell types based on marker genes</li> <li>Map query data to the reference atlas</li> <li>Transfer annotations between datasets</li> <li>Compute 'presence scores' for query data based on the reference atlas</li> <li>Perform differential expression analysis</li> </ul> <p>Here is a quick start guide to the basic functions. More detailed vignettes will be available soon.</p>"},{"location":"vignettes/get_started/#annotation","title":"\ud83d\udd8b\ufe0f Annotation","text":"<p>We developed snapseed to rapidly annotate the HNOCA. It annotates cells based on manually defined sets of marker genes for individual cell types or cell type hierarchies. It is fast (i.e. GPU-accelerated) and simple to enable annotation of very large datasets.</p> <pre><code>import hnoca.snapseed as snap\nfrom hnoca.snapseed.utils import read_yaml\n\n# Read in the marker genes\nmarker_genes = read_yaml(\"marker_genes.yaml\")\n\n# Annotate anndata objects\nsnap.annotate(\n    adata,\n    marker_genes,\n    group_name=\"clusters\",\n    layer=\"lognorm\",\n)\n\n# Or for more complex hierarchies\nsnap.annotate_hierarchy(\n    adata,\n    marker_genes,\n    group_name=\"clusters\",\n    layer=\"lognorm\",\n)\n</code></pre>"},{"location":"vignettes/get_started/#mapping","title":"\ud83d\uddfa\ufe0f Mapping","text":"<p>For reference mapping, we mostly rely on scPoli and scANVI. Based on pretrained models, we here provide a simple interface to map query data to the reference atlas.</p> <pre><code>import scvi\nimport hnoca.map as mapping\n\n# Load the reference model\nref_model = scvi.model.SCANVI.load(\n    os.path.join(\"model.pt\"),\n    adata=ref_adata,\n)\n\n# Map query data\nmapper = mapping.AtlasMapper(ref_model)\nmapper.map_query(query_adata, retrain=\"partial\", max_epochs=100, batch_size=1024)\n</code></pre> <p>Now that the query dataset is mapped, we can perform kNN-based label transfer and presence score calculation.</p> <pre><code># Compute the weighted kNN\nmapper.compute_wknn(k=100)\n\n# Transfer labels\ncelltype_transfer = mapper.transfer_labels(label_key=\"cell_type\")\npresence_scores = mapper.get_presence_scores(split_by=\"batch\")\n</code></pre>"},{"location":"vignettes/get_started/#differential-expression","title":"\ud83d\udcca Differential expression","text":"<p>We have used ANOVA for DE analysis between the HNOCA and the reference atlas. Here, this is implemented as the <code>test_de()</code> function.</p> <pre><code>import hnoca.stats as stats\n\n# Perform DE analysis\nde_df = stats.test_de(\n    joint_adata,\n    group_key=\"origin\",\n    return_coef_group=\"organoid\",\n    adjust_method=\"holm\",\n)\n</code></pre> <p>In addition to DE testing on the atlas itself, we found it useful to treat the atlas as a universal \"control\" and test for DE w.r.t query datasets. For this, we first compute the matched expression profile for each cell in the query dataset and then test for DE using an F-test.</p> <pre><code># Compute matched expression profiles based on mapped data\nmatched_adata = mapper.get_matched_expression()\n\n# Perform DE analysis\nde_df = stats.test_de_paired(\n    query_adata,\n    matched_adata,\n    adjust_method=\"holm\",\n)\n</code></pre>"}]}